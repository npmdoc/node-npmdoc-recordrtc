<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="http://RecordRTC.org/"

    >recordrtc (v5.4.1)</a>
</h1>
<h4>RecordRTC is a server-less (entire client-side) JavaScript library can be used to record WebRTC audio/video media streams. It supports cross-browser audio/video recording.</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.recordrtc">module recordrtc</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.recordrtc">
            function <span class="apidocSignatureSpan"></span>recordrtc
            <span class="apidocSignatureSpan">(mediaStream, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.CanvasRecorder">
            function <span class="apidocSignatureSpan">recordrtc.</span>CanvasRecorder
            <span class="apidocSignatureSpan">(htmlElement, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.GifRecorder">
            function <span class="apidocSignatureSpan">recordrtc.</span>GifRecorder
            <span class="apidocSignatureSpan">(mediaStream, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.MRecordRTC">
            function <span class="apidocSignatureSpan">recordrtc.</span>MRecordRTC
            <span class="apidocSignatureSpan">(mediaStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.MediaStreamRecorder">
            function <span class="apidocSignatureSpan">recordrtc.</span>MediaStreamRecorder
            <span class="apidocSignatureSpan">(mediaStream, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.MultiStreamRecorder">
            function <span class="apidocSignatureSpan">recordrtc.</span>MultiStreamRecorder
            <span class="apidocSignatureSpan">(arrayOfMediaStreams, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.StereoAudioRecorder">
            function <span class="apidocSignatureSpan">recordrtc.</span>StereoAudioRecorder
            <span class="apidocSignatureSpan">(mediaStream, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.Whammy.Video">
            function <span class="apidocSignatureSpan">recordrtc.</span>Whammy.Video
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.WhammyRecorder">
            function <span class="apidocSignatureSpan">recordrtc.</span>WhammyRecorder
            <span class="apidocSignatureSpan">(mediaStream, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.getFromDisk">
            function <span class="apidocSignatureSpan">recordrtc.</span>getFromDisk
            <span class="apidocSignatureSpan">(type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.writeToDisk">
            function <span class="apidocSignatureSpan">recordrtc.</span>writeToDisk
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recordrtc.</span>DiskStorage</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recordrtc.</span>Storage</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recordrtc.</span>Whammy</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recordrtc.</span>Whammy.Video.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recordrtc.DiskStorage">module recordrtc.DiskStorage</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.DiskStorage.Fetch">
            function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>Fetch
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.DiskStorage.Store">
            function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>Store
            <span class="apidocSignatureSpan">(config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.DiskStorage.init">
            function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>init
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.DiskStorage.onError">
            function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>onError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>dbName</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>dataStoreName</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recordrtc.MRecordRTC">module recordrtc.MRecordRTC</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.MRecordRTC.MRecordRTC">
            function <span class="apidocSignatureSpan">recordrtc.</span>MRecordRTC
            <span class="apidocSignatureSpan">(mediaStream)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.MRecordRTC.getFromDisk">
            function <span class="apidocSignatureSpan">recordrtc.MRecordRTC.</span>getFromDisk
            <span class="apidocSignatureSpan">(type, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.MRecordRTC.writeToDisk">
            function <span class="apidocSignatureSpan">recordrtc.MRecordRTC.</span>writeToDisk
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recordrtc.Whammy">module recordrtc.Whammy</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.Whammy.Video">
            function <span class="apidocSignatureSpan">recordrtc.Whammy.</span>Video
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recordrtc.Whammy.Video">module recordrtc.Whammy.Video</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.Whammy.Video.Video">
            function <span class="apidocSignatureSpan">recordrtc.Whammy.</span>Video
            <span class="apidocSignatureSpan">(duration)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.recordrtc.Whammy.Video.prototype">module recordrtc.Whammy.Video.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.Whammy.Video.prototype.add">
            function <span class="apidocSignatureSpan">recordrtc.Whammy.Video.prototype.</span>add
            <span class="apidocSignatureSpan">(frame, duration)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.recordrtc.Whammy.Video.prototype.compile">
            function <span class="apidocSignatureSpan">recordrtc.Whammy.Video.prototype.</span>compile
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recordrtc" id="apidoc.module.recordrtc">module recordrtc</a></h1>


    <h2>
        <a href="#apidoc.element.recordrtc.recordrtc" id="apidoc.element.recordrtc.recordrtc">
        function <span class="apidocSignatureSpan"></span>recordrtc
        <span class="apidocSignatureSpan">(mediaStream, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function RecordRTC(mediaStream, config) {
    if (!mediaStream) {
        throw &#x27;MediaStream is mandatory.&#x27;;
    }

    config = config || {
        type: &#x27;video&#x27;
    };

    config = new RecordRTCConfiguration(mediaStream, config);

    // a reference to user&#x27;s recordRTC object
    var self = this;

    function startRecording() {
        if (!config.disableLogs) {
            console.debug(&#x27;started recording &#x27; + config.type + &#x27; stream.&#x27;);
        }

        if (mediaRecorder) {
            mediaRecorder.clearRecordedData();
            mediaRecorder.record();

            if (self.recordingDuration) {
                handleRecordingDuration();
            }
            return self;
        }

        initRecorder(function() {
            if (self.recordingDuration) {
                handleRecordingDuration();
            }
        });

        return self;
    }

    function initRecorder(initCallback) {
        if (initCallback) {
            config.initCallback = function() {
                initCallback();
                initCallback = config.initCallback = null; // recordRTC.initRecorder should be call-backed once.
            };
        }

        var Recorder = new GetRecorderType(mediaStream, config);

        mediaRecorder = new Recorder(mediaStream, config);
        mediaRecorder.record();

        if (!config.disableLogs) {
            console.debug(&#x27;Initialized recorderType:&#x27;, mediaRecorder.constructor.name, &#x27;for output-type:&#x27;, config.type);
        }
    }

    function stopRecording(callback) {
        if (!mediaRecorder) {
            return console.warn(WARNING);
        }

<span class="apidocCodeCommentSpan">        /*jshint validthis:true */
</span>        var recordRTC = this;

        if (!config.disableLogs) {
            console.warn(&#x27;Stopped recording &#x27; + config.type + &#x27; stream.&#x27;);
        }

        if (config.type !== &#x27;gif&#x27;) {
            mediaRecorder.stop(_callback);
        } else {
            mediaRecorder.stop();
            _callback();
        }

        function _callback(__blob) {
            for (var item in mediaRecorder) {
                if (self) {
                    self[item] = mediaRecorder[item];
                }

                if (recordRTC) {
                    recordRTC[item] = mediaRecorder[item];
                }
            }

            var blob = mediaRecorder.blob;

            if (!blob) {
                if (__blob) {
                    mediaRecorder.blob = blob = __blob;
                } else {
                    throw &#x27;Recording failed.&#x27;;
                }
            }

            if (callback) {
                var url = URL.createObjectURL(blob);
                callback(url);
            }

            if (blob &#x26;&#x26; !config.disableLogs) {
                console.debug(blob.type, &#x27;-&#x3e;&#x27;, bytesToSize(blob.size));
            }

            if (!config.autoWriteToDisk) {
                return;
            }

            getDataURL(function(dataURL) {
                var parameter = {};
                parameter[config.type + &#x27;Blob&#x27;] = dataURL;
                DiskStorage.Store(parameter);
            });
        }
    }

    function pauseRecording() {
        if (!mediaRecorder) {
            return console.warn(WARNING);
        }

        mediaRecorder.pause();

        if (!config.disableLogs) {
            console.debug(&#x27;Paused recording.&#x27;);
        }
    }

    function resumeRecording() {
        if (!mediaRecorder) {
            return console.warn(WARNING);
        }

        // not all libs have this method yet
        mediaRecorder.resume();

        if (!config.disableLogs) {
            console.debug(&#x27;Resumed recording.&#x27;);
        }
    }

    function readFile(_blob) {
        postMessage(new FileReaderSync().readAsDataURL(_blob));
    }

    function getDataURL(callback, _mediaRecorder) {
        if (!callback) {
            throw &#x27;Pass a callback function over getDataURL.&#x27;;
        }

        var blob = _mediaRecorder ? _mediaRecorder.blob : (mediaRecorder || {}).blob;

        if (!blob) {
            if (!config.disableLogs) {
                console.warn(&#x27;Blob encoder did not f ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.CanvasRecorder" id="apidoc.element.recordrtc.CanvasRecorder">
        function <span class="apidocSignatureSpan">recordrtc.</span>CanvasRecorder
        <span class="apidocSignatureSpan">(htmlElement, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function CanvasRecorder(htmlElement, config) {
    if (typeof html2canvas === &#x27;undefined&#x27; &#x26;&#x26; htmlElement.nodeName.toLowerCase() !== &#x27;canvas&#x27;) {
        throw &#x27;Please link: https://cdn.webrtc-experiment.com/screenshot.js&#x27;;
    }

    config = config || {};
    if (!config.frameInterval) {
        config.frameInterval = 10;
    }

    // via DetectRTC.js
    var isCanvasSupportsStreamCapturing = false;
    [&#x27;captureStream&#x27;, &#x27;mozCaptureStream&#x27;, &#x27;webkitCaptureStream&#x27;].forEach(function(item) {
        if (item in document.createElement(&#x27;canvas&#x27;)) {
            isCanvasSupportsStreamCapturing = true;
        }
    });

    var _isChrome = (!!window.webkitRTCPeerConnection || !!window.webkitGetUserMedia) &#x26;&#x26; !!window.chrome;

    var chromeVersion = 50;
    var matchArray = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
    if (_isChrome &#x26;&#x26; matchArray &#x26;&#x26; matchArray[2]) {
        chromeVersion = parseInt(matchArray[2], 10);
    }

    if (_isChrome &#x26;&#x26; chromeVersion &#x3c; 52) {
        isCanvasSupportsStreamCapturing = false;
    }

    var globalCanvas, mediaStreamRecorder;

    if (isCanvasSupportsStreamCapturing) {
        if (!config.disableLogs) {
            console.debug(&#x27;Your browser supports both MediRecorder API and canvas.captureStream!&#x27;);
        }

        if (htmlElement instanceof HTMLCanvasElement) {
            globalCanvas = htmlElement;
        } else if (htmlElement instanceof CanvasRenderingContext2D) {
            globalCanvas = htmlElement.canvas;
        } else {
            throw &#x27;Please pass either HTMLCanvasElement or CanvasRenderingContext2D.&#x27;;
        }
    } else if (!!navigator.mozGetUserMedia) {
        if (!config.disableLogs) {
            console.error(&#x27;Canvas recording is NOT supported in Firefox.&#x27;);
        }
    }

    var isRecording;

<span class="apidocCodeCommentSpan">    /**
     * This method records Canvas.
     * @method
     * @memberof CanvasRecorder
     * @example
     * recorder.record();
     */
</span>    this.record = function() {
        isRecording = true;

        if (isCanvasSupportsStreamCapturing) {
            // CanvasCaptureMediaStream
            var canvasMediaStream;
            if (&#x27;captureStream&#x27; in globalCanvas) {
                canvasMediaStream = globalCanvas.captureStream(25); // 25 FPS
            } else if (&#x27;mozCaptureStream&#x27; in globalCanvas) {
                canvasMediaStream = globalCanvas.mozCaptureStream(25);
            } else if (&#x27;webkitCaptureStream&#x27; in globalCanvas) {
                canvasMediaStream = globalCanvas.webkitCaptureStream(25);
            }

            try {
                var mdStream = new MediaStream();
                mdStream.addTrack(canvasMediaStream.getVideoTracks()[0]);
                canvasMediaStream = mdStream;
            } catch (e) {}

            if (!canvasMediaStream) {
                throw &#x27;captureStream API are NOT available.&#x27;;
            }

            // Note: Jan 18, 2016 status is that,
            // Firefox MediaRecorder API can&#x27;t record CanvasCaptureMediaStream object.
            mediaStreamRecorder = new MediaStreamRecorder(canvasMediaStream, {
                mimeType: &#x27;video/webm&#x27;
            });
            mediaStreamRecorder.record();
        } else {
            whammy.frames = [];
            lastTime = new Date().getTime();
            drawCanvasFrame();
        }

        if (config.initCallback) {
            config.initCallback();
        }
    };

    this.getWebPImages = function(callback) {
        if (htmlElement.nodeName.toLowerCase() !== &#x27;canvas&#x27;) {
            callback();
            return;
        }

        var framesLength = whammy.frames.length;
        whammy.frames.forEach(function(frame, idx) {
            var framesRemaining = framesLength - idx;
            if (!config.disableLogs) {
                console.debug(framesRemaining + &#x27;/&#x27; + framesLength + &#x27; frames remaining&#x27;);
            }

            if (config.onEncodingCallback) {
                config.onEncodingCallback(framesRemaining, framesLength);
            }

            var webp = frame.image.toDataURL(&#x27;image/webp&#x27;, 1);
            whammy.frames[idx] ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.GifRecorder" id="apidoc.element.recordrtc.GifRecorder">
        function <span class="apidocSignatureSpan">recordrtc.</span>GifRecorder
        <span class="apidocSignatureSpan">(mediaStream, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function GifRecorder(mediaStream, config) {
    if (typeof GIFEncoder === &#x27;undefined&#x27;) {
        throw &#x27;Please link: https://cdn.webrtc-experiment.com/gif-recorder.js&#x27;;
    }

    config = config || {};

    var isHTMLObject = mediaStream instanceof CanvasRenderingContext2D || mediaStream instanceof HTMLCanvasElement;

<span class="apidocCodeCommentSpan">    /**
     * This method records MediaStream.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.record();
     */
</span>    this.record = function() {
        if (!isHTMLObject) {
            if (!config.width) {
                config.width = video.offsetWidth || 320;
            }

            if (!this.height) {
                config.height = video.offsetHeight || 240;
            }

            if (!config.video) {
                config.video = {
                    width: config.width,
                    height: config.height
                };
            }

            if (!config.canvas) {
                config.canvas = {
                    width: config.width,
                    height: config.height
                };
            }

            canvas.width = config.canvas.width || 320;
            canvas.height = config.canvas.height || 240;

            video.width = config.video.width || 320;
            video.height = config.video.height || 240;
        }

        // external library to record as GIF images
        gifEncoder = new GIFEncoder();

        // void setRepeat(int iter)
        // Sets the number of times the set of GIF frames should be played.
        // Default is 1; 0 means play indefinitely.
        gifEncoder.setRepeat(0);

        // void setFrameRate(Number fps)
        // Sets frame rate in frames per second.
        // Equivalent to setDelay(1000/fps).
        // Using &#x22;setDelay&#x22; instead of &#x22;setFrameRate&#x22;
        gifEncoder.setDelay(config.frameRate || 200);

        // void setQuality(int quality)
        // Sets quality of color quantization (conversion of images to the
        // maximum 256 colors allowed by the GIF specification).
        // Lower values (minimum = 1) produce better colors,
        // but slow processing significantly. 10 is the default,
        // and produces good color mapping at reasonable speeds.
        // Values greater than 20 do not yield significant improvements in speed.
        gifEncoder.setQuality(config.quality || 10);

        // Boolean start()
        // This writes the GIF Header and returns false if it fails.
        gifEncoder.start();

        startTime = Date.now();

        var self = this;

        function drawVideoFrame(time) {
            if (isPausedRecording) {
                return setTimeout(function() {
                    drawVideoFrame(time);
                }, 100);
            }

            lastAnimationFrame = requestAnimationFrame(drawVideoFrame);

            if (typeof lastFrameTime === undefined) {
                lastFrameTime = time;
            }

            // ~10 fps
            if (time - lastFrameTime &#x3c; 90) {
                return;
            }

            if (!isHTMLObject &#x26;&#x26; video.paused) {
                // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316
                // Tweak for Android Chrome
                video.play();
            }

            if (!isHTMLObject) {
                context.drawImage(video, 0, 0, canvas.width, canvas.height);
            }

            if (config.onGifPreview) {
                config.onGifPreview(canvas.toDataURL(&#x27;image/png&#x27;));
            }

            gifEncoder.addFrame(context);
            lastFrameTime = time;
        }

        lastAnimationFrame = requestAnimationFrame(drawVideoFrame);

        if (config.initCallback) {
            config.initCallback();
        }
    };

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof GifRecorder
     * @example
     * recorder.stop(function(blob) {
     *     img.src = URL.createObjectURL(blob);
     * }); ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.MRecordRTC" id="apidoc.element.recordrtc.MRecordRTC">
        function <span class="apidocSignatureSpan">recordrtc.</span>MRecordRTC
        <span class="apidocSignatureSpan">(mediaStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MRecordRTC(mediaStream) {

<span class="apidocCodeCommentSpan">    /**
     * This method attaches MediaStream object to {@link MRecordRTC}.
     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded
 or WebAudio API.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.addStream(MediaStream);
     */
</span>    this.addStream = function(_mediaStream) {
        if (_mediaStream) {
            mediaStream = _mediaStream;
        }
    };

    /**
     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.
     * @property {object} mediaType - {audio: true, video: true, gif: true}
     * @memberof MRecordRTC
     * @example
     * var recorder = new MRecordRTC();
     * recorder.mediaType = {
     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder
     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder
     *     gif  : true  // TRUE or GifRecorder
     * };
     */
    this.mediaType = {
        audio: true,
        video: true
    };

    /**
     * This method starts recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.startRecording();
     */
    this.startRecording = function() {
        var mediaType = this.mediaType;
        var recorderType;
        var mimeType = this.mimeType || {
            audio: null,
            video: null,
            gif: null
        };

        if (typeof mediaType.audio !== &#x27;function&#x27; &#x26;&#x26; isMediaRecorderCompatible() &#x26;&#x26; mediaStream.getAudioTracks &#x26;&#x26; !mediaStream.getAudioTracks
().length) {
            // Firefox supports both audio/video in single blob
            mediaType.audio = false;
        }

        if (typeof mediaType.video !== &#x27;function&#x27; &#x26;&#x26; isMediaRecorderCompatible() &#x26;&#x26; mediaStream.getVideoTracks &#x26;&#x26; !mediaStream.getVideoTracks
().length) {
            // Firefox supports both audio/video in single blob
            mediaType.video = false;
        }

        if (!mediaType.audio &#x26;&#x26; !mediaType.video) {
            throw &#x27;MediaStream must have either audio or video tracks.&#x27;;
        }

        if (!!mediaType.audio) {
            recorderType = null;
            if (typeof mediaType.audio === &#x27;function&#x27;) {
                recorderType = mediaType.audio;
            }

            this.audioRecorder = new RecordRTC(mediaStream, {
                type: &#x27;audio&#x27;,
                bufferSize: this.bufferSize,
                sampleRate: this.sampleRate,
                numberOfAudioChannels: this.numberOfAudioChannels || 2,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.audio
            });

            if (!mediaType.video) {
                this.audioRecorder.startRecording();
            }
        }

        if (!!mediaType.video) {
            recorderType = null;
            if (typeof mediaType.video === &#x27;function&#x27;) {
                recorderType = mediaType.video;
            }

            var newStream = mediaStream;

            if (isMediaRecorderCompatible() &#x26;&#x26; !!mediaType.audio &#x26;&#x26; typeof mediaType.audio === &#x27;function&#x27;) {
                var videoTrack = mediaStream.getVideoTracks()[0];

                if (!!navigator.mozGetUserMedia) {
                    newStream = new MediaStream();
                    newStream.addTrack(videoTrack);

                    if (recorderType &#x26;&#x26; recorderType === WhammyRecorder) {
                        // Firefox does NOT support webp-encoding yet
                        recorderType = MediaStreamRecorder;
                    }
                } else {
                    newStream = new MediaStream([videoTrack]);
                }
            }

            this.videoRecorder = new RecordRTC(newStream, {
                type: &#x27;video&#x27;,
                video: this.video,
                canvas: this.canvas,
                frameInterval: this.frameInterval || 10,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.MediaStreamRecorder" id="apidoc.element.recordrtc.MediaStreamRecorder">
        function <span class="apidocSignatureSpan">recordrtc.</span>MediaStreamRecorder
        <span class="apidocSignatureSpan">(mediaStream, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MediaStreamRecorder(mediaStream, config) {
    var self = this;

    config = config || {
        // bitsPerSecond: 256 * 8 * 1024,
        mimeType: &#x27;video/webm&#x27;
    };

    if (config.type === &#x27;audio&#x27;) {
        if (mediaStream.getVideoTracks().length &#x26;&#x26; mediaStream.getAudioTracks().length) {
            var stream;
            if (!!navigator.mozGetUserMedia) {
                stream = new MediaStream();
                stream.addTrack(mediaStream.getAudioTracks()[0]);
            } else {
                // webkitMediaStream
                stream = new MediaStream(mediaStream.getAudioTracks());
            }
            mediaStream = stream;
        }

        if (!config.mimeType || config.mimeType.toString().toLowerCase().indexOf(&#x27;audio&#x27;) === -1) {
            config.mimeType = isChrome ? &#x27;audio/webm&#x27; : &#x27;audio/ogg&#x27;;
        }

        if (config.mimeType &#x26;&#x26; config.mimeType.toString().toLowerCase() !== &#x27;audio/ogg&#x27; &#x26;&#x26; !!navigator.mozGetUserMedia) {
            // forcing better codecs on Firefox (via #166)
            config.mimeType = &#x27;audio/ogg&#x27;;
        }
    }

<span class="apidocCodeCommentSpan">    /**
     * This method records MediaStream.
     * @method
     * @memberof MediaStreamRecorder
     * @example
     * recorder.record();
     */
</span>    this.record = function() {
        self.blob = null;

        var recorderHints = config;

        if (!config.disableLogs) {
            console.log(&#x27;Passing following config over MediaRecorder API.&#x27;, recorderHints);
        }

        if (mediaRecorder) {
            // mandatory to make sure Firefox doesn&#x27;t fails to record streams 3-4 times without reloading the page.
            mediaRecorder = null;
        }

        if (isChrome &#x26;&#x26; !isMediaRecorderCompatible()) {
            // to support video-only recording on stable
            recorderHints = &#x27;video/vp8&#x27;;
        }

        if (typeof MediaRecorder.isTypeSupported === &#x27;function&#x27; &#x26;&#x26; recorderHints.mimeType) {
            if (!MediaRecorder.isTypeSupported(recorderHints.mimeType)) {
                if (!config.disableLogs) {
                    console.warn(&#x27;MediaRecorder API seems unable to record mimeType:&#x27;, recorderHints.mimeType);
                }

                recorderHints.mimeType = config.type === &#x27;audio&#x27; ? &#x27;audio/webm&#x27; : &#x27;video/webm&#x27;;
            }
        }

        // http://dxr.mozilla.org/mozilla-central/source/content/media/MediaRecorder.cpp
        // https://wiki.mozilla.org/Gecko:MediaRecorder
        // https://dvcs.w3.org/hg/dap/raw-file/default/media-stream-capture/MediaRecorder.html

        // starting a recording session; which will initiate &#x22;Reading Thread&#x22;
        // &#x22;Reading Thread&#x22; are used to prevent main-thread blocking scenarios
        try {
            mediaRecorder = new MediaRecorder(mediaStream, recorderHints);
        } catch (e) {
            mediaRecorder = new MediaRecorder(mediaStream);
        }

        if (!MediaRecorder.isTypeSupported &#x26;&#x26; &#x27;canRecordMimeType&#x27; in mediaRecorder &#x26;&#x26; mediaRecorder.canRecordMimeType(config.mimeType
) === false) {
            if (!config.disableLogs) {
                console.warn(&#x27;MediaRecorder API seems unable to record mimeType:&#x27;, config.mimeType);
            }
        }

        // i.e. stop recording when &#x3c;video&#x3e; is paused by the user; and auto restart recording
        // when video is resumed. E.g. yourStream.getVideoTracks()[0].muted = true; // it will auto-stop recording.
        mediaRecorder.ignoreMutedMedia = config.ignoreMutedMedia || false;

        // Dispatching OnDataAvailable Handler
        mediaRecorder.ondataavailable = function(e) {
            if (self.dontFireOnDataAvailableEvent) {
                return;
            }

            if (!e.data || !e.data.size || e.data.size &#x3c; 100 || self.blob) {
                // make sure that stopRecording always getting fired
                // even if there is invalid data
                if (self.recordingCallback) {
                    self.recordingCallback(new Blob([], {
                        type: recorderHints.mimeType || &#x27;video/webm&#x27;
                    }));
                    self.recordin ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.MultiStreamRecorder" id="apidoc.element.recordrtc.MultiStreamRecorder">
        function <span class="apidocSignatureSpan">recordrtc.</span>MultiStreamRecorder
        <span class="apidocSignatureSpan">(arrayOfMediaStreams, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MultiStreamRecorder(arrayOfMediaStreams, options) {
    var self = this;

    options = options || {
        mimeType: &#x27;video/webm&#x27;,
        video: {
            width: 320,
            height: 240
        }
    };

    if (!options.frameInterval) {
        options.frameInterval = 10;
    }

    if (!options.video) {
        options.video = {};
    }

    if (!options.video.width) {
        options.video.width = 320;
    }

    if (!options.video.height) {
        options.video.height = 240;
    }

<span class="apidocCodeCommentSpan">    /**
     * This method records all MediaStreams.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.record();
     */
</span>    this.record = function() {
        isStoppedRecording = false;
        var mixedVideoStream = getMixedVideoStream();

        var mixedAudioStream = getMixedAudioStream();
        if (mixedAudioStream) {
            mixedAudioStream.getAudioTracks().forEach(function(track) {
                mixedVideoStream.addTrack(track);
            });
        }

        if (options.previewStream &#x26;&#x26; typeof options.previewStream === &#x27;function&#x27;) {
            options.previewStream(mixedVideoStream);
        }

        mediaRecorder = new MediaStreamRecorder(mixedVideoStream, {
            mimeType: &#x27;video/webm&#x27;
        });

        canvas.width = videos.length &#x3e; 1 ? videos[0].width * 2 : videos[0].width;
        canvas.height = videos.length &#x3e; 2 ? videos[0].height * 2 : videos[0].height;

        drawVideosToCanvas();

        mediaRecorder.record();
    };

    /**
     * This method stops recording MediaStream.
     * @param {function} callback - Callback function, that is used to pass recorded blob back to the callee.
     * @method
     * @memberof MultiStreamRecorder
     * @example
     * recorder.stop(function(blob) {
     *     video.src = URL.createObjectURL(blob);
     * });
     */
    this.stop = function(callback) {
        isStoppedRecording = true;

        if (!mediaRecorder) {
            return;
        }

        mediaRecorder.stop(function(blob) {
            callback(blob);
        });
    };

    function getMixedAudioStream() {
        // via: @pehrsons
        var audioContext = new AudioContext();
        var audioSources = [];

        var audioTracksLength = 0;
        arrayOfMediaStreams.forEach(function(stream) {
            if (!stream.getAudioTracks().length) {
                return;
            }

            audioTracksLength++;

            audioSources.push(audioContext.createMediaStreamSource(stream));
        });

        if (!audioTracksLength) {
            return;
        }

        var audioiDestination = audioContext.createMediaStreamDestination();
        audioSources.forEach(function(audioSource) {
            audioSource.connect(audioiDestination);
        });
        return audioiDestination.stream;
    }

    var videos = [];
    var mediaRecorder;

    function getMixedVideoStream() {
        // via: @adrian-ber
        arrayOfMediaStreams.forEach(function(stream) {
            if (!stream.getVideoTracks().length) {
                return;
            }

            var video = getVideo(stream);
            video.width = options.video.width;
            video.height = options.video.height;
            videos.push(video);
        });

        var capturedStream;

        if (&#x27;captureStream&#x27; in canvas) {
            capturedStream = canvas.captureStream();
        } else if (&#x27;mozCaptureStream&#x27; in canvas) {
            capturedStream = canvas.mozCaptureStream();
        } else if (!options.disableLogs) {
            console.error(&#x27;captureStream API requires this flag: chrome://flags/#enable-experimental-web-platform-features&#x27;);
        }

        return capturedStream;
    }

    function getVideo(stream) {
        var video = document.createElement(&#x27;video&#x27;);
        video.src = URL.createObjectURL(stream);
        video.play();
        return video;
    }

    var isStoppedRecording = false;

    function drawVideosToCanvas() {
        if (isStoppedRecording) {
            return;
        }

        var videosLength = videos.lengt ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.StereoAudioRecorder" id="apidoc.element.recordrtc.StereoAudioRecorder">
        function <span class="apidocSignatureSpan">recordrtc.</span>StereoAudioRecorder
        <span class="apidocSignatureSpan">(mediaStream, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function StereoAudioRecorder(mediaStream, config) {
    if (!mediaStream.getAudioTracks().length) {
        throw &#x27;Your stream has no audio tracks.&#x27;;
    }

    config = config || {};

    var self = this;

    // variables
    var leftchannel = [];
    var rightchannel = [];
    var recording = false;
    var recordingLength = 0;
    var jsAudioNode;

    var numberOfAudioChannels = 2;

    // backward compatibility
    if (config.leftChannel === true) {
        numberOfAudioChannels = 1;
    }

    if (config.numberOfAudioChannels === 1) {
        numberOfAudioChannels = 1;
    }

    if (!config.disableLogs) {
        console.debug(&#x27;StereoAudioRecorder is set to record number of channels: &#x27;, numberOfAudioChannels);
    }

    function isMediaStreamActive() {
        if (&#x27;active&#x27; in mediaStream) {
            if (!mediaStream.active) {
                return false;
            }
        } else if (&#x27;ended&#x27; in mediaStream) { // old hack
            if (mediaStream.ended) {
                return false;
            }
        }
        return true;
    }

<span class="apidocCodeCommentSpan">    /**
     * This method records MediaStream.
     * @method
     * @memberof StereoAudioRecorder
     * @example
     * recorder.record();
     */
</span>    this.record = function() {
        if (isMediaStreamActive() === false) {
            throw &#x27;Please make sure MediaStream is active.&#x27;;
        }

        // reset the buffers for the new recording
        leftchannel.length = rightchannel.length = 0;
        recordingLength = 0;

        if (audioInput) {
            audioInput.connect(jsAudioNode);
        }

        // to prevent self audio to be connected with speakers
        // jsAudioNode.connect(context.destination);

        isAudioProcessStarted = isPaused = false;
        recording = true;
    };

    function mergeLeftRightBuffers(config, callback) {
        function mergeAudioBuffers(config, cb) {
            var numberOfAudioChannels = config.numberOfAudioChannels;

            // todo: &#x22;slice(0)&#x22; --- is it causes loop? Should be removed?
            var leftBuffers = config.leftBuffers.slice(0);
            var rightBuffers = config.rightBuffers.slice(0);
            var sampleRate = config.sampleRate;
            var internalInterleavedLength = config.internalInterleavedLength;

            if (numberOfAudioChannels === 2) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
                rightBuffers = mergeBuffers(rightBuffers, internalInterleavedLength);
            }

            if (numberOfAudioChannels === 1) {
                leftBuffers = mergeBuffers(leftBuffers, internalInterleavedLength);
            }

            function mergeBuffers(channelBuffer, rLength) {
                var result = new Float64Array(rLength);
                var offset = 0;
                var lng = channelBuffer.length;

                for (var i = 0; i &#x3c; lng; i++) {
                    var buffer = channelBuffer[i];
                    result.set(buffer, offset);
                    offset += buffer.length;
                }

                return result;
            }

            function interleave(leftChannel, rightChannel) {
                var length = leftChannel.length + rightChannel.length;

                var result = new Float64Array(length);

                var inputIndex = 0;

                for (var index = 0; index &#x3c; length;) {
                    result[index++] = leftChannel[inputIndex];
                    result[index++] = rightChannel[inputIndex];
                    inputIndex++;
                }
                return result;
            }

            function writeUTFBytes(view, offset, string) {
                var lng = string.length;
                for (var i = 0; i &#x3c; lng; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }

            // interleave both channels together
            var interleaved;

            if (numberOfAudioChannels === 2) {
                interleaved = interleave(leftBuffers, rightBuffers);
            }

            if ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.Whammy.Video" id="apidoc.element.recordrtc.Whammy.Video">
        function <span class="apidocSignatureSpan">recordrtc.</span>Whammy.Video
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WhammyVideo(duration) {
    this.frames = [];
    this.duration = duration || 1;
    this.quality = 0.8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.WhammyRecorder" id="apidoc.element.recordrtc.WhammyRecorder">
        function <span class="apidocSignatureSpan">recordrtc.</span>WhammyRecorder
        <span class="apidocSignatureSpan">(mediaStream, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WhammyRecorder(mediaStream, config) {

    config = config || {};

    if (!config.frameInterval) {
        config.frameInterval = 10;
    }

    if (!config.disableLogs) {
        console.log(&#x27;Using frames-interval:&#x27;, config.frameInterval);
    }

<span class="apidocCodeCommentSpan">    /**
     * This method records video.
     * @method
     * @memberof WhammyRecorder
     * @example
     * recorder.record();
     */
</span>    this.record = function() {
        if (!config.width) {
            config.width = 320;
        }

        if (!config.height) {
            config.height = 240;
        }

        if (!config.video) {
            config.video = {
                width: config.width,
                height: config.height
            };
        }

        if (!config.canvas) {
            config.canvas = {
                width: config.width,
                height: config.height
            };
        }

        canvas.width = config.canvas.width || 320;
        canvas.height = config.canvas.height || 240;

        context = canvas.getContext(&#x27;2d&#x27;);

        // setting defaults
        if (config.video &#x26;&#x26; config.video instanceof HTMLVideoElement) {
            video = config.video.cloneNode();

            if (config.initCallback) {
                config.initCallback();
            }
        } else {
            video = document.createElement(&#x27;video&#x27;);

            if (typeof video.srcObject !== &#x27;undefined&#x27;) {
                video.srcObject = mediaStream;
            } else {
                video.src = URL.createObjectURL(mediaStream);
            }

            video.onloadedmetadata = function() { // &#x22;onloadedmetadata&#x22; may NOT work in FF?
                if (config.initCallback) {
                    config.initCallback();
                }
            };

            video.width = config.video.width;
            video.height = config.video.height;
        }

        video.muted = true;
        video.play();

        lastTime = new Date().getTime();
        whammy = new Whammy.Video();

        if (!config.disableLogs) {
            console.log(&#x27;canvas resolutions&#x27;, canvas.width, &#x27;*&#x27;, canvas.height);
            console.log(&#x27;video width/height&#x27;, video.width || canvas.width, &#x27;*&#x27;, video.height || canvas.height);
        }

        drawFrames(config.frameInterval);
    };

    /**
     * Draw and push frames to Whammy
     * @param {integer} frameInterval - set minimum interval (in milliseconds) between each time we push a frame to Whammy
     */
    function drawFrames(frameInterval) {
        frameInterval = typeof frameInterval !== &#x27;undefined&#x27; ? frameInterval : 10;

        var duration = new Date().getTime() - lastTime;
        if (!duration) {
            return setTimeout(drawFrames, frameInterval, frameInterval);
        }

        if (isPausedRecording) {
            lastTime = new Date().getTime();
            return setTimeout(drawFrames, 100);
        }

        // via #206, by Jack i.e. @Seymourr
        lastTime = new Date().getTime();

        if (video.paused) {
            // via: https://github.com/muaz-khan/WebRTC-Experiment/pull/316
            // Tweak for Android Chrome
            video.play();
        }

        context.drawImage(video, 0, 0, canvas.width, canvas.height);
        whammy.frames.push({
            duration: duration,
            image: canvas.toDataURL(&#x27;image/webp&#x27;)
        });

        if (!isStopDrawing) {
            setTimeout(drawFrames, frameInterval, frameInterval);
        }
    }

    function asyncLoop(o) {
        var i = -1,
            length = o.length;

        var loop = function() {
            i++;
            if (i === length) {
                o.callback();
                return;
            }
            o.functionToLoop(loop, i);
        };
        loop(); //init
    }


    /**
     * remove black frames from the beginning to the specified frame
     * @param {Array} _frames - array of frames to be checked
     * @param {number} _framesToCheck - number of frame until check will be executed (-1 - will drop all frames until frame not
matched will be found)
     * @param {number} _pi ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.getFromDisk" id="apidoc.element.recordrtc.getFromDisk">
        function <span class="apidocSignatureSpan">recordrtc.</span>getFromDisk
        <span class="apidocSignatureSpan">(type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromDisk = function (type, callback) {
    if (!callback) {
        throw &#x27;callback is mandatory.&#x27;;
    }

    console.log(&#x27;Getting recorded &#x27; + (type === &#x27;all&#x27; ? &#x27;blobs&#x27; : type + &#x27; blob &#x27;) + &#x27; from disk!&#x27;);
    DiskStorage.Fetch(function(dataURL, _type) {
        if (type !== &#x27;all&#x27; &#x26;&#x26; _type === type + &#x27;Blob&#x27; &#x26;&#x26; callback) {
            callback(dataURL);
        }

        if (type === &#x27;all&#x27; &#x26;&#x26; callback) {
            callback(dataURL, _type.replace(&#x27;Blob&#x27;, &#x27;&#x27;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## `getFromDisk`

You can get recorded blob from disk using `getFromDisk` method:

```javascript
// get all blobs from disk
RecordRTC.<span class="apidocCodeKeywordSpan">getFromDisk</span>(&#x27;all&#x27;, function(dataURL, type) {
   type == &#x27;audio&#x27;
   type == &#x27;video&#x27;
   type == &#x27;gif&#x27;
});

// or get just single blob
RecordRTC.getFromDisk(&#x27;audio&#x27;, function(dataURL) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.writeToDisk" id="apidoc.element.recordrtc.writeToDisk">
        function <span class="apidocSignatureSpan">recordrtc.</span>writeToDisk
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeToDisk = function (options) {
    console.log(&#x27;Writing recorded blob(s) to disk!&#x27;);
    options = options || {};
    if (options.audio &#x26;&#x26; options.video &#x26;&#x26; options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                options.gif.getDataURL(function(gifDataURL) {
                    DiskStorage.Store({
                        audioBlob: audioDataURL,
                        videoBlob: videoDataURL,
                        gifBlob: gifDataURL
                    });
                });
            });
        });
    } else if (options.audio &#x26;&#x26; options.video) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    videoBlob: videoDataURL
                });
            });
        });
    } else if (options.audio &#x26;&#x26; options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.video &#x26;&#x26; options.gif) {
        options.video.getDataURL(function(videoDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    videoBlob: videoDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.audio) {
        options.audio.getDataURL(function(audioDataURL) {
            DiskStorage.Store({
                audioBlob: audioDataURL
            });
        });
    } else if (options.video) {
        options.video.getDataURL(function(videoDataURL) {
            DiskStorage.Store({
                videoBlob: videoDataURL
            });
        });
    } else if (options.gif) {
        options.gif.getDataURL(function(gifDataURL) {
            DiskStorage.Store({
                gifBlob: gifDataURL
            });
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## `writeToDisk`

You can write recorded blob to disk using `writeToDisk` method:

```javascript
recordRTC.stopRecording();
recordRTC.<span class="apidocCodeKeywordSpan">writeToDisk</span>();
```

## `getFromDisk`

You can get recorded blob from disk using `getFromDisk` method:

```javascript
...</pre></li>
    </ul>










</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recordrtc.DiskStorage" id="apidoc.module.recordrtc.DiskStorage">module recordrtc.DiskStorage</a></h1>


    <h2>
        <a href="#apidoc.element.recordrtc.DiskStorage.Fetch" id="apidoc.element.recordrtc.DiskStorage.Fetch">
        function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>Fetch
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Fetch = function (callback) {
    this.callback = callback;
    this.init();

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 */
RecordRTC.getFromDisk = function(type, callback) {
    if (!callback) {
throw &#x27;callback is mandatory.&#x27;;
    }

    console.log(&#x27;Getting recorded &#x27; + (type === &#x27;all&#x27; ? &#x27;blobs&#x27; : type + &#x27; blob &#x27;) + &#x27
; from disk!&#x27;);
    DiskStorage.<span class="apidocCodeKeywordSpan">Fetch</span>(function(dataURL, _type) {
if (type !== &#x27;all&#x27; &#x26;&#x26; _type === type + &#x27;Blob&#x27; &#x26;&#x26; callback) {
    callback(dataURL);
}

if (type === &#x27;all&#x27; &#x26;&#x26; callback) {
    callback(dataURL, _type.replace(&#x27;Blob&#x27;, &#x27;&#x27;));
}
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.DiskStorage.Store" id="apidoc.element.recordrtc.DiskStorage.Store">
        function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>Store
        <span class="apidocSignatureSpan">(config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">Store = function (config) {
    this.audioBlob = config.audioBlob;
    this.videoBlob = config.videoBlob;
    this.gifBlob = config.gifBlob;

    this.init();

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
        if (!config.autoWriteToDisk) {
            return;
        }

        getDataURL(function(dataURL) {
            var parameter = {};
            parameter[config.type + &#x27;Blob&#x27;] = dataURL;
            DiskStorage.<span class="apidocCodeKeywordSpan">Store</span>(parameter);
        });
    }
}

function pauseRecording() {
    if (!mediaRecorder) {
        return console.warn(WARNING);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.DiskStorage.init" id="apidoc.element.recordrtc.DiskStorage.init">
        function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>init
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">init = function () {
    var self = this;

    if (typeof indexedDB === &#x27;undefined&#x27; || typeof indexedDB.open === &#x27;undefined&#x27;) {
        console.error(&#x27;IndexedDB API are not available in this browser.&#x27;);
        return;
    }

    var dbVersion = 1;
    var dbName = this.dbName || location.href.replace(/\/|:|#|%|\.|\[|\]/g, &#x27;&#x27;),
        db;
    var request = indexedDB.open(dbName, dbVersion);

    function createObjectStore(dataBase) {
        dataBase.createObjectStore(self.dataStoreName);
    }

    function putInDB() {
        var transaction = db.transaction([self.dataStoreName], &#x27;readwrite&#x27;);

        if (self.videoBlob) {
            transaction.objectStore(self.dataStoreName).put(self.videoBlob, &#x27;videoBlob&#x27;);
        }

        if (self.gifBlob) {
            transaction.objectStore(self.dataStoreName).put(self.gifBlob, &#x27;gifBlob&#x27;);
        }

        if (self.audioBlob) {
            transaction.objectStore(self.dataStoreName).put(self.audioBlob, &#x27;audioBlob&#x27;);
        }

        function getFromStore(portionName) {
            transaction.objectStore(self.dataStoreName).get(portionName).onsuccess = function(event) {
                if (self.callback) {
                    self.callback(event.target.result, portionName);
                }
            };
        }

        getFromStore(&#x27;audioBlob&#x27;);
        getFromStore(&#x27;videoBlob&#x27;);
        getFromStore(&#x27;gifBlob&#x27;);
    }

    request.onerror = self.onError;

    request.onsuccess = function() {
        db = request.result;
        db.onerror = self.onError;

        if (db.setVersion) {
            if (db.version !== dbVersion) {
                var setVersion = db.setVersion(dbVersion);
                setVersion.onsuccess = function() {
                    createObjectStore(db);
                    putInDB();
                };
            } else {
                putInDB();
            }
        } else {
            putInDB();
        }
    };
    request.onupgradeneeded = function(event) {
        createObjectStore(event.target.result);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var DiskStorage = {
    /**
     * This method must be called once to initialize IndexedDB ObjectStore. Though, it is auto-used internally.
     * @method
     * @memberof DiskStorage
     * @internal
     * @example
     * DiskStorage.<span class="apidocCodeKeywordSpan">init</span>();
     */
    init: function() {
var self = this;

if (typeof indexedDB === &#x27;undefined&#x27; || typeof indexedDB.open === &#x27;undefined&#x27;) {
    console.error(&#x27;IndexedDB API are not available in this browser.&#x27;);
    return;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.DiskStorage.onError" id="apidoc.element.recordrtc.DiskStorage.onError">
        function <span class="apidocSignatureSpan">recordrtc.DiskStorage.</span>onError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">onError = function (error) {
    console.error(JSON.stringify(error, null, &#x27;\t&#x27;));
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    this.retryHandler.reset();
    this.sendFile_();
  }
};

MediaUploader.prototype.onContentUploadError_ = function(e) {
  if (e.target.status &#x26;&#x26; e.target.status &#x3c; 500) {
    this.<span class="apidocCodeKeywordSpan">onError</span>(e.target.response);
  } else {
    this.retryHandler.retry(this.resume_.bind(this));
  }
};

MediaUploader.prototype.onUploadError_ = function(e) {
  this.onError(e.target.response); // TODO - Retries for initial upload
...</pre></li>
    </ul>






</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recordrtc.MRecordRTC" id="apidoc.module.recordrtc.MRecordRTC">module recordrtc.MRecordRTC</a></h1>


    <h2>
        <a href="#apidoc.element.recordrtc.MRecordRTC.MRecordRTC" id="apidoc.element.recordrtc.MRecordRTC.MRecordRTC">
        function <span class="apidocSignatureSpan">recordrtc.</span>MRecordRTC
        <span class="apidocSignatureSpan">(mediaStream)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function MRecordRTC(mediaStream) {

<span class="apidocCodeCommentSpan">    /**
     * This method attaches MediaStream object to {@link MRecordRTC}.
     * @param {MediaStream} mediaStream - A MediaStream object, either fetched using getUserMedia API, or generated using captureStreamUntilEnded
 or WebAudio API.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.addStream(MediaStream);
     */
</span>    this.addStream = function(_mediaStream) {
        if (_mediaStream) {
            mediaStream = _mediaStream;
        }
    };

    /**
     * This property can be used to set the recording type e.g. audio, or video, or gif, or canvas.
     * @property {object} mediaType - {audio: true, video: true, gif: true}
     * @memberof MRecordRTC
     * @example
     * var recorder = new MRecordRTC();
     * recorder.mediaType = {
     *     audio: true, // TRUE or StereoAudioRecorder or MediaStreamRecorder
     *     video: true, // TRUE or WhammyRecorder or MediaStreamRecorder
     *     gif  : true  // TRUE or GifRecorder
     * };
     */
    this.mediaType = {
        audio: true,
        video: true
    };

    /**
     * This method starts recording.
     * @method
     * @memberof MRecordRTC
     * @example
     * recorder.startRecording();
     */
    this.startRecording = function() {
        var mediaType = this.mediaType;
        var recorderType;
        var mimeType = this.mimeType || {
            audio: null,
            video: null,
            gif: null
        };

        if (typeof mediaType.audio !== &#x27;function&#x27; &#x26;&#x26; isMediaRecorderCompatible() &#x26;&#x26; mediaStream.getAudioTracks &#x26;&#x26; !mediaStream.getAudioTracks
().length) {
            // Firefox supports both audio/video in single blob
            mediaType.audio = false;
        }

        if (typeof mediaType.video !== &#x27;function&#x27; &#x26;&#x26; isMediaRecorderCompatible() &#x26;&#x26; mediaStream.getVideoTracks &#x26;&#x26; !mediaStream.getVideoTracks
().length) {
            // Firefox supports both audio/video in single blob
            mediaType.video = false;
        }

        if (!mediaType.audio &#x26;&#x26; !mediaType.video) {
            throw &#x27;MediaStream must have either audio or video tracks.&#x27;;
        }

        if (!!mediaType.audio) {
            recorderType = null;
            if (typeof mediaType.audio === &#x27;function&#x27;) {
                recorderType = mediaType.audio;
            }

            this.audioRecorder = new RecordRTC(mediaStream, {
                type: &#x27;audio&#x27;,
                bufferSize: this.bufferSize,
                sampleRate: this.sampleRate,
                numberOfAudioChannels: this.numberOfAudioChannels || 2,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType: mimeType.audio
            });

            if (!mediaType.video) {
                this.audioRecorder.startRecording();
            }
        }

        if (!!mediaType.video) {
            recorderType = null;
            if (typeof mediaType.video === &#x27;function&#x27;) {
                recorderType = mediaType.video;
            }

            var newStream = mediaStream;

            if (isMediaRecorderCompatible() &#x26;&#x26; !!mediaType.audio &#x26;&#x26; typeof mediaType.audio === &#x27;function&#x27;) {
                var videoTrack = mediaStream.getVideoTracks()[0];

                if (!!navigator.mozGetUserMedia) {
                    newStream = new MediaStream();
                    newStream.addTrack(videoTrack);

                    if (recorderType &#x26;&#x26; recorderType === WhammyRecorder) {
                        // Firefox does NOT support webp-encoding yet
                        recorderType = MediaStreamRecorder;
                    }
                } else {
                    newStream = new MediaStream([videoTrack]);
                }
            }

            this.videoRecorder = new RecordRTC(newStream, {
                type: &#x27;video&#x27;,
                video: this.video,
                canvas: this.canvas,
                frameInterval: this.frameInterval || 10,
                disableLogs: this.disableLogs,
                recorderType: recorderType,
                mimeType ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.MRecordRTC.getFromDisk" id="apidoc.element.recordrtc.MRecordRTC.getFromDisk">
        function <span class="apidocSignatureSpan">recordrtc.MRecordRTC.</span>getFromDisk
        <span class="apidocSignatureSpan">(type, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFromDisk = function (type, callback) {
    if (!callback) {
        throw &#x27;callback is mandatory.&#x27;;
    }

    console.log(&#x27;Getting recorded &#x27; + (type === &#x27;all&#x27; ? &#x27;blobs&#x27; : type + &#x27; blob &#x27;) + &#x27; from disk!&#x27;);
    DiskStorage.Fetch(function(dataURL, _type) {
        if (type !== &#x27;all&#x27; &#x26;&#x26; _type === type + &#x27;Blob&#x27; &#x26;&#x26; callback) {
            callback(dataURL);
        }

        if (type === &#x27;all&#x27; &#x26;&#x26; callback) {
            callback(dataURL, _type.replace(&#x27;Blob&#x27;, &#x27;&#x27;));
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## `getFromDisk`

You can get recorded blob from disk using `getFromDisk` method:

```javascript
// get all blobs from disk
RecordRTC.<span class="apidocCodeKeywordSpan">getFromDisk</span>(&#x27;all&#x27;, function(dataURL, type) {
   type == &#x27;audio&#x27;
   type == &#x27;video&#x27;
   type == &#x27;gif&#x27;
});

// or get just single blob
RecordRTC.getFromDisk(&#x27;audio&#x27;, function(dataURL) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.MRecordRTC.writeToDisk" id="apidoc.element.recordrtc.MRecordRTC.writeToDisk">
        function <span class="apidocSignatureSpan">recordrtc.MRecordRTC.</span>writeToDisk
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeToDisk = function (options) {
    console.log(&#x27;Writing recorded blob(s) to disk!&#x27;);
    options = options || {};
    if (options.audio &#x26;&#x26; options.video &#x26;&#x26; options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                options.gif.getDataURL(function(gifDataURL) {
                    DiskStorage.Store({
                        audioBlob: audioDataURL,
                        videoBlob: videoDataURL,
                        gifBlob: gifDataURL
                    });
                });
            });
        });
    } else if (options.audio &#x26;&#x26; options.video) {
        options.audio.getDataURL(function(audioDataURL) {
            options.video.getDataURL(function(videoDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    videoBlob: videoDataURL
                });
            });
        });
    } else if (options.audio &#x26;&#x26; options.gif) {
        options.audio.getDataURL(function(audioDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    audioBlob: audioDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.video &#x26;&#x26; options.gif) {
        options.video.getDataURL(function(videoDataURL) {
            options.gif.getDataURL(function(gifDataURL) {
                DiskStorage.Store({
                    videoBlob: videoDataURL,
                    gifBlob: gifDataURL
                });
            });
        });
    } else if (options.audio) {
        options.audio.getDataURL(function(audioDataURL) {
            DiskStorage.Store({
                audioBlob: audioDataURL
            });
        });
    } else if (options.video) {
        options.video.getDataURL(function(videoDataURL) {
            DiskStorage.Store({
                videoBlob: videoDataURL
            });
        });
    } else if (options.gif) {
        options.gif.getDataURL(function(gifDataURL) {
            DiskStorage.Store({
                gifBlob: gifDataURL
            });
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

## `writeToDisk`

You can write recorded blob to disk using `writeToDisk` method:

```javascript
recordRTC.stopRecording();
recordRTC.<span class="apidocCodeKeywordSpan">writeToDisk</span>();
```

## `getFromDisk`

You can get recorded blob from disk using `getFromDisk` method:

```javascript
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recordrtc.Whammy" id="apidoc.module.recordrtc.Whammy">module recordrtc.Whammy</a></h1>


    <h2>
        <a href="#apidoc.element.recordrtc.Whammy.Video" id="apidoc.element.recordrtc.Whammy.Video">
        function <span class="apidocSignatureSpan">recordrtc.Whammy.</span>Video
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WhammyVideo(duration) {
    this.frames = [];
    this.duration = duration || 1;
    this.quality = 0.8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var RecordRTC = require(&#x27;recordrtc&#x27;);
var Whammy = RecordRTC.Whammy;
var WhammyRecorder = RecordRTC.WhammyRecorder;
var StereoAudioRecorder = RecordRTC.StereoAudioRecorder;
// and so on

var video = new Whammy.<span class="apidocCodeKeywordSpan">Video</span>(100);
var recorder = new StereoAudioRecorder(stream, options);
```

```html
&#x3c;!-- link npm package scripts --&#x3e;
&#x3c;script src=&#x22;./node_modules/recordrtc/RecordRTC.js&#x22;&#x3e;&#x3c;/script&#x3e;
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recordrtc.Whammy.Video" id="apidoc.module.recordrtc.Whammy.Video">module recordrtc.Whammy.Video</a></h1>


    <h2>
        <a href="#apidoc.element.recordrtc.Whammy.Video.Video" id="apidoc.element.recordrtc.Whammy.Video.Video">
        function <span class="apidocSignatureSpan">recordrtc.Whammy.</span>Video
        <span class="apidocSignatureSpan">(duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function WhammyVideo(duration) {
    this.frames = [];
    this.duration = duration || 1;
    this.quality = 0.8;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```javascript
var RecordRTC = require(&#x27;recordrtc&#x27;);
var Whammy = RecordRTC.Whammy;
var WhammyRecorder = RecordRTC.WhammyRecorder;
var StereoAudioRecorder = RecordRTC.StereoAudioRecorder;
// and so on

var video = new Whammy.<span class="apidocCodeKeywordSpan">Video</span>(100);
var recorder = new StereoAudioRecorder(stream, options);
```

```html
&#x3c;!-- link npm package scripts --&#x3e;
&#x3c;script src=&#x22;./node_modules/recordrtc/RecordRTC.js&#x22;&#x3e;&#x3c;/script&#x3e;
```
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.recordrtc.Whammy.Video.prototype" id="apidoc.module.recordrtc.Whammy.Video.prototype">module recordrtc.Whammy.Video.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.recordrtc.Whammy.Video.prototype.add" id="apidoc.element.recordrtc.Whammy.Video.prototype.add">
        function <span class="apidocSignatureSpan">recordrtc.Whammy.Video.prototype.</span>add
        <span class="apidocSignatureSpan">(frame, duration)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">add = function (frame, duration) {
    if (&#x27;canvas&#x27; in frame) { //CanvasRenderingContext2D
        frame = frame.canvas;
    }

    if (&#x27;toDataURL&#x27; in frame) {
        frame = frame.toDataURL(&#x27;image/webp&#x27;, this.quality);
    }

    if (!(/^data:image\/webp;base64,/ig).test(frame)) {
        throw &#x27;Input must be formatted properly as a base64 encoded DataURI of type image/webp&#x27;;
    }
    this.frames.push({
        image: frame,
        duration: duration || this.duration
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
 * @summary A real time javascript webm encoder based on a canvas hack.
 * @license {@link https://github.com/muaz-khan/RecordRTC#license|MIT}
 * @author {@link http://www.MuazKhan.com|Muaz Khan}
 * @typedef Whammy
 * @class
 * @example
 * var recorder = new Whammy().Video(15);
 * recorder.<span class="apidocCodeKeywordSpan">add</span>(context || canvas || dataURL);
 * var output = recorder.compile();
 * @see {@link https://github.com/muaz-khan/RecordRTC|RecordRTC Source Code}
 */

var Whammy = (function() {
// a more abstract-ish API
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.recordrtc.Whammy.Video.prototype.compile" id="apidoc.element.recordrtc.Whammy.Video.prototype.compile">
        function <span class="apidocSignatureSpan">recordrtc.Whammy.Video.prototype.</span>compile
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">compile = function (callback) {
    var webWorker = processInWebWorker(whammyInWebWorker);

    webWorker.onmessage = function(event) {
        if (event.data.error) {
            console.error(event.data.error);
            return;
        }
        callback(event.data);
    };

    webWorker.postMessage(this.frames);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
             * @property {Blob} blob - Recorded frames in video/webm blob.
             * @memberof CanvasRecorder
             * @example
             * recorder.stop(function() {
             *     var blob = recorder.blob;
             * });
             */
            whammy.<span class="apidocCodeKeywordSpan">compile</span>(function(blob) {
if (!config.disableLogs) {
    console.debug(&#x27;Recording finished!&#x27;);
}

that.blob = blob;

if (that.blob.forEach) {
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
